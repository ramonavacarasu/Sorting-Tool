type: edu
custom_name: stage6
files:
- name: src/sorting/Main.java
  visible: true
  text: |
    package sorting;

    import java.io.*;
    import java.util.*;

    public class Main {
        public static void main(final String[] args)  throws IOException {

            String dataType = "word";
            String sortingType = "natural";
            String inputFile = null;
            String outputFile = null;
            Scanner scanner = null;
            FileWriter writer = null;
            FileReadAndWrite1 helper1 = null;


            Set<String> sortTypes = Set.of("natural", "bycount");
            Set<String> dataTypes = Set.of("word", "long", "line");


            for (int i = 0; i < args.length; i++) {
                switch (args[i]) {
                    case "-sortingType":
                        if (i + 1 >= args.length || !sortTypes.contains(args[i + 1].toLowerCase())) {
                            System.out.println("No sorting type defined!");
                            return;
                        }
                        sortingType = args[++i];
                        break;
                    case "-dataType":
                        if (i + 1 >= args.length || !dataTypes.contains(args[i + 1].toLowerCase())) {
                            System.out.println("No data type defined!");
                            return;
                        }
                        dataType = args[++i];
                        break;
                    case "-inputFile":
                        inputFile = args[++i];
                        scanner = new Scanner(new File(inputFile));
                        break;
                    case "-outputFile":
                        outputFile = args[++i];
                        writer = new FileWriter(new File(outputFile));
                        break;
                    default:
                        System.out.printf("\"%s\" isn't a valid parameter. It's skipped.%n",
                                args[i]);
                        break;
                }
            }

            if (scanner != null && writer != null) {
                helper1 = new FileReadAndWrite1(scanner, writer);
                scanner.close();
                writer.close();
            }

            myMethods solution = myMethodsFactory.getInstance(sortingType, inputFile, outputFile, helper1);
            assert solution != null;
            solution.solve(dataType);

        }
    }

    abstract class myMethods {

        protected Scanner scanner;
        protected FileWriter writer;
        protected String inputFile;
        protected String outputFile;

        myMethods(String inputFile, String outputFile) {
            this.inputFile = inputFile;
            this.outputFile = outputFile;
        }

        void setHelper(FileReadAndWrite1 helper1) {
            this.scanner = helper1.scanner;
            this.writer = helper1.write;
        }

        void solve(String dataType)  throws IOException  {
            switch (dataType) {
                case "long":
                    argLong(inputFile, outputFile);
                    break;
                case "line":
                    argLine(inputFile, outputFile);
                    break;
                case "word":
                    argWord(inputFile, outputFile);
                    break;
                default:
                    System.out.println("No data type defined!");
                    writer.write("No data type defined!");
                    writer.close();
                    break;
            }
        }

        abstract void argLong(String inputFile, String outputFile) throws IOException;
        abstract void argLine(String inputFile, String outputFile) throws IOException;
        abstract void argWord(String inputFile, String outputFile) throws IOException;

    }

    abstract class myMethodsFactory {

        static myMethods getInstance(String sortingType, String inputFile, String outputFile, FileReadAndWrite1 helper1) {
            myMethods methods = new Natural1(inputFile, outputFile);
            if ("byCount".equals(sortingType)) {
                methods = new byCount(inputFile, outputFile);
            } else if (("natural".equals(sortingType))) {
                methods = new Natural1(inputFile, outputFile);
            }

            if (helper1 != null) {
                methods.setHelper(helper1);
            }
            return methods;
        }
    }

    class FileReadAndWrite1 {
        Scanner scanner;
        FileWriter write;
        FileReadAndWrite1(Scanner inputFile, FileWriter outputFile) {
            this.scanner = inputFile;
            this.write = outputFile;
        }
    }

    class Natural1 extends myMethods {

        Natural1(String inputFile, String outputFile) {
            super(inputFile, outputFile);
        }
        static Scanner scan = new Scanner(System.in);

        public void argLong(String inputFile, String outputFile) throws IOException {

            ArrayList<Integer> listInt = new ArrayList<>();

            if (inputFile != null) {
                while (scanner.hasNext()) {
                    int nextNumber = scanner.nextInt();
                    listInt.add(nextNumber);
                }
                scanner.close();
            } else {
                while (scan.hasNext()) {
                    int nextNumber = scan.nextInt();
                    listInt.add(nextNumber);
                }
            }

            Collections.sort(listInt);

            StringBuilder sb = new StringBuilder();
            for (int z : listInt) {
                sb.append(z).append(" ");
            }

            if (outputFile != null) {
                writer.write("Total numbers: " + listInt.size() + ".");
                writer.write("Sorted data: " + sb.toString());
                writer.close();
            } else {
                System.out.println("Total numbers: " + listInt.size() + ".");
                System.out.println("Sorted data: " + sb.toString());
            }
        }

        public void argLine(String inputFile, String outputFile) throws IOException {

            ArrayList<String> listLines = new ArrayList<>();

            if (inputFile != null) {
                while (scanner.hasNext()) {
                    String string = scanner.nextLine();
                    listLines.add(string);
                }
                scanner.close();
            } else {
                while (scan.hasNext()) {
                    String string = scan.nextLine();
                    listLines.add(string);
                }
            }

            Collections.sort(listLines);

            if (outputFile != null) {
                writer.write("Total lines: " + listLines.size() + ".");
                writer.write("Sorted data:");
                for (String z : listLines) {
                    writer.write(z);
                }
                writer.close();
            } else {
                System.out.println("Total lines: " + listLines.size() + ".");
                System.out.println("Sorted data:");
                for (String z : listLines) {
                    System.out.println(z);
                }
            }
        }

        public void argWord(String inputFile, String outputFile) throws IOException {

            ArrayList<String> listWords = new ArrayList<>();

            if (inputFile != null) {
                while (scanner.hasNext()) {
                    String string = scanner.next();
                    listWords.add(string);
                }
                scanner.close();
            } else {
                while (scan.hasNext()) {
                    String string = scan.next();
                    listWords.add(string);
                }
            }

            Collections.sort(listWords);

            StringBuilder sb = new StringBuilder();

            for (String z : listWords) {
                sb.append(z).append(" ");
            }

            if (outputFile != null) {
                writer.write("Total words: " + listWords.size() + ".");
                writer.write("Sorted data: " + sb.toString());
                writer.close();
            } else {
                System.out.println("Total words: " + listWords.size() + ".");
                System.out.println("Sorted data: " + sb.toString());
            }
        }
    }

    class byCount extends myMethods {

        byCount(String inputFile, String outputFile) {
            super(inputFile, outputFile);
        }

        static Scanner scan = new Scanner(System.in);

        public void argLong(String inputFile, String outputFile) throws IOException {

            ArrayList<Integer> listInt = new ArrayList<>();

            Map<Integer, Integer> mapInt = new HashMap<>();

            if (inputFile != null) {
                while (scanner.hasNext()) {
                    int nextNumber = scanner.nextInt();
                    listInt.add(nextNumber);
                }
                scanner.close();
            } else {
                while (scan.hasNext()) {
                    int nextNumber = scan.nextInt();
                    listInt.add(nextNumber);
                }
            }

            for (int z : listInt) {
                if (!mapInt.containsKey(z)) {
                    mapInt.put(z, 1);
                } else {
                    mapInt.put(z, mapInt.get(z) + 1);
                }
            }

            LinkedHashMap<String, Integer> sortedMapInt = new LinkedHashMap<>();

            mapInt.entrySet()
                    .stream()
                    .sorted(Map.Entry.comparingByValue())
                    .forEachOrdered(x -> sortedMapInt.put(String.valueOf(x.getKey()), x.getValue()));

            if (outputFile != null) {
                writer.write("Total numbers: " + listInt.size() + ".");
                for (String i : sortedMapInt.keySet()) {
                    int perc = 100 * sortedMapInt.get(i) / mapInt.size();
                    writer.write(i + ": " + sortedMapInt.get(i) + " time(s), " + perc + "%");
                }
                writer.close();
            } else {
                System.out.println("Total numbers: " + listInt.size() + ".");
                for (String i : sortedMapInt.keySet()) {
                    int perc = 100 * sortedMapInt.get(i) / mapInt.size();
                    System.out.println(i + ": " + sortedMapInt.get(i) + " time(s), " + perc + "%");
                }
            }
        }

        public void argLine(String inputFile, String outputFile) throws IOException {

            ArrayList<String> listLines = new ArrayList<>();

            Map<String, Integer> mapLines = new LinkedHashMap<>();

            if (inputFile != null) {
                while (scanner.hasNext()) {
                    String string = scanner.nextLine();
                    listLines.add(string);
                }
                scanner.close();
            } else {
                while (scan.hasNext()) {
                    String string = scan.nextLine();
                    listLines.add(string);
                }
            }

            Collections.sort(listLines);

            for (String str : listLines) {
                if (!mapLines.containsKey(str)) {
                    mapLines.put(str, 1);
                } else {
                    mapLines.put(str, mapLines.get(str) + 1);
                }
            }

            LinkedHashMap<String, Integer> sortedMapInt = new LinkedHashMap<>();

            mapLines.entrySet()
                    .stream()
                    .sorted(Map.Entry.comparingByValue())
                    .forEachOrdered(x -> sortedMapInt.put(String.valueOf(x.getKey()), x.getValue()));

            if (outputFile != null) {
                writer.write("Total lines: " + listLines.size() + ".");
                for (String i : sortedMapInt.keySet()) {
                    int perc = 100 * sortedMapInt.get(i) / mapLines.size();
                    writer.write(i + ": " + sortedMapInt.get(i) + " time(s), " + perc + "%");
                }
                writer.close();
            } else {
                System.out.println("Total lines: " + listLines.size() + ".");
                for (String i : sortedMapInt.keySet()) {
                    int perc = 100 * sortedMapInt.get(i) / mapLines.size();
                    System.out.println(i + ": " + sortedMapInt.get(i) + " time(s), " + perc + "%");
                }
            }
        }

        public void argWord(String inputFile, String outputFile) throws IOException {

            ArrayList<String> listWords = new ArrayList<>();
            Map<String, Integer> mapWords = new LinkedHashMap<>();

            if (inputFile != null) {
                while (scanner.hasNext()) {
                    String string = scanner.next();
                    listWords.add(string);
                }
                scanner.close();
            } else {
                while (scan.hasNext()) {
                    String string = scan.next();
                    listWords.add(string);
                }
            }
            Collections.sort(listWords);


            for (String str : listWords) {
                if (!mapWords.containsKey(str)) {
                    mapWords.put(str, 1);
                } else {
                    mapWords.put(str, mapWords.get(str) + 1);
                }
            }

            LinkedHashMap<String, Integer> sortedMapWord = new LinkedHashMap<>();

            mapWords.entrySet()
                    .stream()
                    .sorted(Map.Entry.comparingByValue())
                    .forEachOrdered(x -> sortedMapWord.put(String.valueOf(x.getKey()), x.getValue()));

            if (outputFile != null) {
                writer.write("Total words: " + listWords.size() + ".");
                for (String i : sortedMapWord.keySet()) {
                    int perc = 100 * sortedMapWord.get(i) / listWords.size();
                    writer.write(i + ": " + sortedMapWord.get(i) + " time(s), " + perc + "%");
                }
                writer.close();
            } else {
                System.out.println("Total words: " + listWords.size() + ".");
                for (String i : sortedMapWord.keySet()) {
                    int perc = 100 * sortedMapWord.get(i) / listWords.size();
                    System.out.println(i + ": " + sortedMapWord.get(i) + " time(s), " + perc + "%");
                }
            }
            scan.close();
        }
    }
  learner_created: false
- name: test/SortingTest.java
  visible: false
  text: |
    import common.SortingToolStage6Test;

    public class SortingTest extends SortingToolStage6Test {

    }
  learner_created: false
- name: test/common/SortingToolStage6Test.kt
  visible: false
  text: |+
    package common

    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult
    import org.hyperskill.hstest.testcase.TestCase
    import sorting.Main
    import java.io.File
    import java.io.FileNotFoundException
    import java.util.*

    abstract class SortingToolStage6Test : StageTest<SortingToolClue>(Main::class.java) {

        override fun generate(): List<TestCase<SortingToolClue>> {
            return stage4Tests() + stage5Tests() + stage6Tests()
        }

        override fun check(reply: String, clue: SortingToolClue): CheckResult {
            @Suppress("NAME_SHADOWING") var reply = reply

            val fileNameArgIdx = clue.args.indexOf("-outputFile")

            if (fileNameArgIdx != -1) {
                val fileName = clue.args[fileNameArgIdx + 1]

                try {
                    reply = File(fileName).readText()
                } catch (ex: FileNotFoundException) {
                    return CheckResult.wrong(
                        "There is no output file $fileName"
                    )
                }

            }

            return when {
                badArgs(clue.args) -> CheckResult(true)  // TODO: test something here
                "byCount" in clue.args -> checkByCount(reply, clue)
                else -> checkNatural(reply, clue)
            }
        }

        private fun checkByCount(reply: String, clue: SortingToolClue): CheckResult {
            return when {
                "long" in clue.args -> checkByCount(parseLongTokens(clue.consoleInput), { it.toInt() }, clue, reply)
                "word" in clue.args -> checkByCount(parseWordTokens(clue.consoleInput), { it }, clue, reply)
                "line" in clue.args -> checkByCount(parseLineTokens(clue.consoleInput), { it }, clue, reply)

                else -> throw IllegalArgumentException("Bad test: no data type found")
            }
        }

        private fun checkNatural(reply: String, clue: SortingToolClue): CheckResult {
            return when {
                "long" in clue.args -> checkNatural(parseLongTokens(clue.consoleInput), ::parseLongTokens, clue, reply)
                "word" in clue.args -> checkNatural(parseWordTokens(clue.consoleInput), ::parseWordTokens, clue, reply)
                "line" in clue.args -> checkNatural(parseLineTokens(clue.consoleInput), ::parseLineTokens, clue, reply)

                else -> throw IllegalArgumentException("Bad test: no data type found")
            }
        }

        private fun badArgs(args: List<String>): Boolean {
            val unknownArgs =
                    args.toSet() - setOf("-dataType", "-sortingType", "long", "word", "line", "natural", "byCount")

            if (unknownArgs.isNotEmpty()) {
                return true
            }

            if (args.last() == "-dataType" || args.last() == "-sortingType") {
                return true
            }

            return false
        }
    }

    private fun fileTestCase(
            input: String,
            revealTest: Boolean,
            file: String,
            vararg args: String = arrayOf("-dataType", "long")
    ): TestCase<SortingToolClue> {
        return TestCase<SortingToolClue>()
                .setAttach(SortingToolClue(input, revealTest, args.toList()))
                .addArguments(*args)
                .addFile(file, input)
    }

    fun stage4Tests(): List<TestCase<SortingToolClue>> {
        return listOf(
                createTest(
                        """
                    |1 -2   333 4
                    |42
                    |1                 1
                    """.trimMargin(),
                        true,
                        "-dataType", "long", "-sortingType", "natural"
                ),
                createTest(
                        """
                    |1 -2   333 4
                    |42
                    |1                 1
                    """.trimMargin(),
                        true,
                        "-dataType", "long"
                ),
                createTest(
                        """
                    |1 -2   333 4
                    |42
                    |1                 1
                    """.trimMargin(),
                        true,
                        "-sortingType", "byCount", "-dataType", "long"
                ),
                createTest(
                        """
                    |1 -2   333 4
                    |42
                    |1                 1
                    """.trimMargin(),
                        true,
                        "-sortingType", "byCount", "-dataType", "word"
                ),
                createTest(
                        """
                    |1 -2   333 4
                    |42
                    |42
                    |1                 1
                    """.trimMargin(),
                        true,
                        "-sortingType", "byCount", "-dataType", "line"
                ),
                createTest(
                        """
                    |1111 1111
                    |22222
                    |3
                    |44
                    """.trimMargin(),
                        false,
                        "-sortingType", "byCount", "-dataType", "line"
                ),
                createTest(
                        """
                    |1111 1111
                    |22222
                    |3
                    |44
                    """.trimMargin(),
                        false,
                        "-sortingType", "byCount", "-dataType", "word"
                ),
                createTest(
                        """
                    |1111 1111
                    |22222
                    |3
                    |44
                    """.trimMargin(),
                        false,
                        "-sortingType", "byCount", "-dataType", "long"
                )
        )
    }

    fun stage5Tests(): List<TestCase<SortingToolClue>> {
        return listOf(
                createTest(
                        """
                    |1 -2   333 4
                    |42
                    |1                 1
                    """.trimMargin(),
                        true,
                        "-sortingType"
                ),
                createTest(
                        """
                    |1 -2   333 4
                    |42
                    |1                 1
                    """.trimMargin(),
                        true,
                        "-sortingType", "byCount", "-dataType", "long", "-abc"
                ),
                createTest(
                        """
                    |1111 1111
                    |22222
                    |3
                    |44
                    """.trimMargin(),
                        false,
                        "-sortingType", "byCount", "-dataType", "line", "-cde"
                ),
                createTest(
                        """
                    |1111 1111
                    |22222
                    |3
                    |44
                    """.trimMargin(),
                        false,
                        "-dataType", "line", "-sortingType"
                )
        )
    }

    fun stage6Tests(): List<TestCase<SortingToolClue>> {
        return listOf(
                fileTestCase(
                        """
                    |1 -2   333 4
                    |42
                    |1                 1
                    """.trimMargin(),
                        true,
                        "input.txt",
                        "-sortingType", "byCount", "-inputFile", "input.txt"
                ),
                fileTestCase(
                        """
                    |1 -2   333 4
                    |42
                    |1                 1
                    """.trimMargin(),
                        true,
                        "data.dat",
                        "-sortingType", "byCount", "-inputFile", "data.dat", "-outputFile", "out.txt"
                ),
                fileTestCase(
                        """
                    |1 -2   333 4
                    |42
                    |1                 1
                    """.trimMargin(),
                        false,
                        "input.txt",
                        "-sortingType", "natural", "-inputFile", "input.txt"
                ),
                fileTestCase(
                        """
                    |1 -2   333 4
                    |42
                    |1                 1
                    """.trimMargin(),
                        false,
                        "data.dat",
                        "-sortingType", "natural", "-inputFile", "data.dat", "-outputFile", "out.txt"
                )
        )
    }


    fun revealRawTest(clue: SortingToolClue, reply: String): String {
        return with(clue) { "Args:\n${args.joinToString(" ")}\nInput:\n$consoleInput\nYour output:\n$reply\n\n" }
    }

    class SortingToolClue(val consoleInput: String, val revealTest: Boolean, val args: List<String>)

    fun createTest(
            consoleInput: String,
            revealTest: Boolean,
            vararg args: String = arrayOf("-dataType", "long")
    ): TestCase<SortingToolClue> {
        return TestCase<SortingToolClue>()
                .setAttach(SortingToolClue(consoleInput, revealTest, args.toList()))
                .setInput(consoleInput)
                .addArguments(*args)
    }

    fun parseLongTokens(input: String): List<Int> {
        val scanner = Scanner(input)

        val longTokens = mutableListOf<Int>()

        while (scanner.hasNextInt()) {
            longTokens.add(scanner.nextInt())
        }

        return longTokens
    }

    fun parseWordTokens(input: String): List<String> {
        val scanner = Scanner(input)

        val wordTokens = mutableListOf<String>()

        while (scanner.hasNext()) {
            wordTokens.add(scanner.next())
        }

        return wordTokens
    }


    fun parseLineTokens(input: String): List<String> {
        return input.lines()
    }


    fun <TokenType : Comparable<TokenType>> checkNatural(
            actualTokens: List<TokenType>,
            sortedTokensParser: (String) -> List<TokenType>,
            clue: SortingToolClue,
            reply_: String
    ): CheckResult {
        val reply = reply_.trim()
        val lines = reply.lines()

        if (lines.size != 2) {
            return if (clue.revealTest) {
                CheckResult(
                        false,
                        "Can't parse your output: expected 2 lines.\n" +
                                revealRawTest(clue, reply)
                )
            } else {
                CheckResult(false, "Can't parse your output: expected 2 lines.")
            }
        }

        val totalRegex = """(\d+)""".toRegex()
        val totalMatchResult = totalRegex.find(lines[0])
        if (totalMatchResult == null) {
            return if (clue.revealTest) {
                CheckResult(
                        false,
                        "Can't find number in the first line of your output.\n" +
                                revealRawTest(clue, reply)
                )
            } else {
                CheckResult(false, "Can't find number in the first line of your output.")
            }
        }

        val totalTokens = totalMatchResult.groupValues[1].toInt()

        val actualTotal = actualTokens.size

        if (actualTotal != totalTokens) {
            return if (clue.revealTest) {
                CheckResult(
                        false,
                        "Total tokens ($totalTokens) are incorrect. Expected: $actualTotal.\n" +
                                revealRawTest(clue, reply)
                )
            } else {
                CheckResult(false, "Total tokens are incorrect.")
            }
        }

        val sortedActualTokens = actualTokens.sorted()

        val sortedTokens = sortedTokensParser(lines[1].substringAfter(":").dropWhile { it in setOf('\n', '\r') })

        val total = sortedTokens.size

        if (actualTotal != total) {
            return if (clue.revealTest) {
                CheckResult(
                        false,
                        "Total sorted tokens ($total) are incorrect. Expected: $actualTotal.\n" +
                                revealRawTest(clue, reply)
                )
            } else {
                CheckResult(false, "Total sorted tokens are incorrect.")
            }
        }

        if (sortedActualTokens != sortedTokens) {
            return if (clue.revealTest) {
                CheckResult(
                        false,
                        "Sorted tokens are incorrect.\n" +
                                revealRawTest(clue, reply)
                )
            } else {
                CheckResult(false, "Sorted tokens are incorrect.")
            }
        }

        return CheckResult(true)
    }


    fun <TokenType : Comparable<TokenType>> checkByCount(
            actualTokens: List<TokenType>,
            tokenParser: (String) -> TokenType,
            clue: SortingToolClue,
            reply_: String
    ): CheckResult {
        val reply = reply_.trim()
        val lines = reply.lines()

        val totalRegex = """(\d+)""".toRegex()
        val totalMatchResult = totalRegex.find(lines[0])
        if (totalMatchResult == null) {
            return if (clue.revealTest) {
                CheckResult(
                        false,
                        "Can't find number in the first line of your output.\n" +
                                revealRawTest(clue, reply)
                )
            } else {
                CheckResult(false, "Can't find number in the first line of your output.")
            }
        }

        val totalTokens = totalMatchResult.groupValues[1].toInt()

        val actualTotal = actualTokens.size

        if (actualTotal != totalTokens) {
            return if (clue.revealTest) {
                CheckResult(
                        false,
                        "Total tokens ($totalTokens) are incorrect. Expected: $actualTotal.\n" +
                                revealRawTest(clue, reply)
                )
            } else {
                CheckResult(false, "Total tokens are incorrect.")
            }
        }

        val tokenToCount = mutableMapOf<TokenType, Int>()

        for (token in actualTokens) {
            tokenToCount[token] = (tokenToCount[token] ?: 0) + 1
        }

        val actualSortedByCount = tokenToCount.toList().sortedWith(compareBy({ it.second }, { it.first }))
        val linesWithTokens = lines.drop(1)

        if (actualSortedByCount.size != linesWithTokens.size) {
            return if (clue.revealTest) {
                CheckResult(
                        false,
                        "Lines with tokens (${linesWithTokens.size}) are incorrect. Expected: ${actualSortedByCount.size}.\n" +
                                revealRawTest(clue, reply)
                )
            } else {
                CheckResult(false, "Lines with tokens are incorrect.")
            }
        }

        for ((lineId, line) in linesWithTokens.withIndex()) {
            val token = tokenParser(line.substringBefore(':'))
            val info = line.substringAfter(':')

            val (actualToken, actualTimes) = actualSortedByCount[lineId]

            if (token != actualToken) {
                return if (clue.revealTest) {
                    CheckResult(
                            false,
                            "Token ($token) is incorrect. Expected: $actualToken.\n" +
                                    revealRawTest(clue, reply)
                    )
                } else {
                    CheckResult(false, "Token is incorrect.")
                }
            }

            // TODO: check info (times and percentage)
        }

        return CheckResult(true)
    }


  learner_created: false
- name: out.txt
  visible: true
  learner_created: true
- name: src/sorting/SortingMethods.java
  visible: true
  learner_created: true
- name: src/sorting/SortingMethodsFactory.java
  visible: true
  learner_created: true
- name: src/sorting/NaturalSort.java
  visible: true
  learner_created: true
- name: src/sorting/SortByCount.java
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/projects/45/stages/244/implement#comment
status: Solved
feedback:
  message: Congratulations! Continue on <a href="https://hyperskill.org/projects/45/stages/244/implement">JetBrains
    Academy</a>
  time: Mon, 16 Nov 2020 11:00:35 UTC
record: 5
